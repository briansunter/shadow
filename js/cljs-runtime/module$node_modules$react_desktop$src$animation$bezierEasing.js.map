{
"version":3,
"file":"module$node_modules$react_desktop$src$animation$bezierEasing.js",
"lineCount":7,
"mappings":"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",
"sources":["node_modules/react-desktop/src/animation/bezierEasing.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$react_desktop$src$animation$bezierEasing\"] = function(global,process,require,module,exports,shadow$shims) {\n'use strict';\n\n/**\n * BezierEasing - use bezier curve for transition easing function\n * by Ga\u00ebtan Renaudeau 2014 - 2015 \u2013 MIT License\n *\n * Credits: is based on Firefox's nsSMILKeySpline.cpp\n * Usage:\n * var spline = BezierEasing([ 0.25, 0.1, 0.25, 1.0 ])\n * spline.get(x) => returns the easing value | x must be in [0, 1] range\n *\n */\n\n// These values are established by empiricism with tests (tradeoff: performance VS precision)\nvar NEWTON_ITERATIONS = 4;\nvar NEWTON_MIN_SLOPE = 0.001;\nvar SUBDIVISION_PRECISION = 0.0000001;\nvar SUBDIVISION_MAX_ITERATIONS = 10;\n\nvar kSplineTableSize = 11;\nvar kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);\n\nvar float32ArraySupported = typeof Float32Array === 'function';\n\nfunction A(aA1, aA2) {\n  return 1.0 - 3.0 * aA2 + 3.0 * aA1;\n}\nfunction B(aA1, aA2) {\n  return 3.0 * aA2 - 6.0 * aA1;\n}\nfunction C(aA1) {\n  return 3.0 * aA1;\n}\n\n// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\nfunction calcBezier(aT, aA1, aA2) {\n  return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;\n}\n\n// Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.\nfunction getSlope(aT, aA1, aA2) {\n  return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);\n}\n\nfunction binarySubdivide(aX, aA, aB, mX1, mX2) {\n  var currentX,\n      currentT,\n      i = 0;\n  do {\n    currentT = aA + (aB - aA) / 2.0;\n    currentX = calcBezier(currentT, mX1, mX2) - aX;\n    if (currentX > 0.0) {\n      aB = currentT;\n    } else {\n      aA = currentT;\n    }\n  } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\n  return currentT;\n}\n\nfunction newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {\n  for (var i = 0; i < NEWTON_ITERATIONS; ++i) {\n    var currentSlope = getSlope(aGuessT, mX1, mX2);\n    if (currentSlope === 0.0) return aGuessT;\n    var currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n    aGuessT -= currentX / currentSlope;\n  }\n  return aGuessT;\n}\n\n/**\n * points is an array of [ mX1, mY1, mX2, mY2 ]\n */\nfunction BezierEasing(points, b, c, d) {\n  if (arguments.length === 4) {\n    return new BezierEasing([points, b, c, d]);\n  }\n  if (!(this instanceof BezierEasing)) return new BezierEasing(points);\n\n  if (!points || points.length !== 4) {\n    throw new Error('BezierEasing: points must contains 4 values');\n  }\n  for (var i = 0; i < 4; ++i) {\n    if (typeof points[i] !== 'number' || isNaN(points[i]) || !isFinite(points[i])) {\n      throw new Error('BezierEasing: points should be integers.');\n    }\n  }\n  if (points[0] < 0 || points[0] > 1 || points[2] < 0 || points[2] > 1) {\n    throw new Error('BezierEasing x values must be in [0, 1] range.');\n  }\n\n  this._str = 'BezierEasing(' + points + ')';\n  this._css = 'cubic-bezier(' + points + ')';\n  this._p = points;\n  this._mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);\n  this._precomputed = false;\n\n  this.get = this.get.bind(this);\n}\n\nBezierEasing.prototype = {\n\n  get: function get(x) {\n    var mX1 = this._p[0],\n        mY1 = this._p[1],\n        mX2 = this._p[2],\n        mY2 = this._p[3];\n    if (!this._precomputed) this._precompute();\n    if (mX1 === mY1 && mX2 === mY2) return x; // linear\n    // Because JavaScript number are imprecise, we should guarantee the extremes are right.\n    if (x === 0) return 0;\n    if (x === 1) return 1;\n    return calcBezier(this._getTForX(x), mY1, mY2);\n  },\n\n  getPoints: function getPoints() {\n    return this._p;\n  },\n\n  toString: function toString() {\n    return this._str;\n  },\n\n  toCSS: function toCSS() {\n    return this._css;\n  },\n\n  // Private part\n\n  _precompute: function _precompute() {\n    var mX1 = this._p[0],\n        mY1 = this._p[1],\n        mX2 = this._p[2],\n        mY2 = this._p[3];\n    this._precomputed = true;\n    if (mX1 !== mY1 || mX2 !== mY2) this._calcSampleValues();\n  },\n\n  _calcSampleValues: function _calcSampleValues() {\n    var mX1 = this._p[0],\n        mX2 = this._p[2];\n    for (var i = 0; i < kSplineTableSize; ++i) {\n      this._mSampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n    }\n  },\n\n  /**\n   * getTForX chose the fastest heuristic to determine the percentage value precisely from a given X projection.\n   */\n  _getTForX: function _getTForX(aX) {\n    var mX1 = this._p[0],\n        mX2 = this._p[2],\n        mSampleValues = this._mSampleValues;\n\n    var intervalStart = 0.0;\n    var currentSample = 1;\n    var lastSample = kSplineTableSize - 1;\n\n    for (; currentSample !== lastSample && mSampleValues[currentSample] <= aX; ++currentSample) {\n      intervalStart += kSampleStepSize;\n    }\n    --currentSample;\n\n    // Interpolate to provide an initial guess for t\n    var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample + 1] - mSampleValues[currentSample]);\n    var guessForT = intervalStart + dist * kSampleStepSize;\n\n    var initialSlope = getSlope(guessForT, mX1, mX2);\n    if (initialSlope >= NEWTON_MIN_SLOPE) {\n      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n    } else if (initialSlope === 0.0) {\n      return guessForT;\n    } else {\n      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);\n    }\n  }\n};\n\n// CSS mapping\nBezierEasing.css = {\n  'ease': BezierEasing.ease = BezierEasing(0.25, 0.1, 0.25, 1.0),\n  'linear': BezierEasing.linear = BezierEasing(0.00, 0.0, 1.00, 1.0),\n  'ease-in': BezierEasing.easeIn = BezierEasing(0.42, 0.0, 1.00, 1.0),\n  'ease-out': BezierEasing.easeOut = BezierEasing(0.00, 0.0, 0.58, 1.0),\n  'ease-in-out': BezierEasing.easeInOut = BezierEasing(0.42, 0.0, 0.58, 1.0)\n};\n\nmodule.exports = BezierEasing;\n};"],
"names":["shadow$provide","global","process","require","module","exports","shadow$shims","calcBezier","aT","aA1","aA2","BezierEasing","points","b","c","d","arguments","length","Error","i","isNaN","isFinite","_str","_css","_p","_mSampleValues","float32ArraySupported","Float32Array","kSplineTableSize","Array","_precomputed","get","bind","prototype","x","mX1","mY1","mX2","mY2","_precompute","_getTForX","getPoints","toString","toCSS","_calcSampleValues","kSampleStepSize","aX","mSampleValues","intervalStart","currentSample","lastSample","guessForT","initialSlope","NEWTON_MIN_SLOPE","NEWTON_ITERATIONS","currentSlope","aGuessT","currentX","currentT","aA","aB","SUBDIVISION_PRECISION","Math","abs","SUBDIVISION_MAX_ITERATIONS","css","ease","linear","easeIn","easeOut","easeInOut"]
}
